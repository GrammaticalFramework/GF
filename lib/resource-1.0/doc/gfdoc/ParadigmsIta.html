<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<META NAME="generator" CONTENT="http://txt2tags.sf.net">
<TITLE> Italian Lexical Paradigms</TITLE>
</HEAD><BODY BGCOLOR="white" TEXT="black">
<P ALIGN="center"><CENTER><H1> Italian Lexical Paradigms</H1>
<FONT SIZE="4">
<I>Last update: 2006-06-22 21:07:00 CEST</I><BR>
</FONT></CENTER>

<P></P>
<HR NOSHADE SIZE=1>
<P></P>
    <UL>
    <LI><A HREF="#toc1">Parameters</A>
    <LI><A HREF="#toc2">Nouns</A>
      <UL>
      <LI><A HREF="#toc3">Compound nouns</A>
      <LI><A HREF="#toc4">Relational nouns</A>
      <LI><A HREF="#toc5">Relational common noun phrases</A>
      <LI><A HREF="#toc6">Proper names and noun phrases</A>
      </UL>
    <LI><A HREF="#toc7">Adjectives</A>
      <UL>
      <LI><A HREF="#toc8">Two-place adjectives</A>
      <LI><A HREF="#toc9">Comparison adjectives</A>
      </UL>
    <LI><A HREF="#toc10">Adverbs</A>
    <LI><A HREF="#toc11">Verbs</A>
      <UL>
      <LI><A HREF="#toc12">Two-place verbs</A>
      <LI><A HREF="#toc13">Three-place verbs</A>
      <LI><A HREF="#toc14">Other complement patterns</A>
      </UL>
    </UL>

<P></P>
<HR NOSHADE SIZE=1>
<P></P>
<P>
Produced by 
gfdoc - a rudimentary GF document generator.
(c) Aarne Ranta (<A HREF="mailto:aarne@cs.chalmers.se">aarne@cs.chalmers.se</A>) 2002 under GNU GPL.
</P>
<P>
Aarne Ranta 2003
</P>
<P>
This is an API for the user of the resource grammar 
for adding lexical items. It gives functions for forming
expressions of open categories: nouns, adjectives, verbs.
</P>
<P>
Closed categories (determiners, pronouns, conjunctions) are
accessed through the resource syntax API, <CODE>Structural.gf</CODE>. 
</P>
<P>
The main difference with <CODE>MorphoIta.gf</CODE> is that the types
referred to are compiled resource grammar types. We have moreover
had the design principle of always having existing forms, rather
than stems, as string arguments of the paradigms.
</P>
<P>
The structure of functions for each word class <CODE>C</CODE> is the following:
first we give a handful of patterns that aim to cover all
regular cases. Then we give a worst-case function <CODE>mkC</CODE>, which serves as an
escape to construct the most irregular words of type <CODE>C</CODE>.
However, this function should only seldom be needed. For verbs, we have a
separate module <A HREF="../../italian/BeschIta.gf"><CODE>BeschIta</CODE></A>,
which covers the <I>Bescherelle</I> verb conjugations.
</P>
<PRE>
    resource ParadigmsIta = 
      open 
        (Predef=Predef), 
        Prelude, 
        CommonRomance, 
        ResIta, 
        MorphoIta, 
        BeschIta,
        CatIta in {
    
      flags optimize=all ;
</PRE>
<P></P>
<A NAME="toc1"></A>
<H2>Parameters</H2>
<P>
To abstract over gender names, we define the following identifiers.
</P>
<PRE>
    oper
      Gender : Type ; 
    
      masculine : Gender ;
      feminine  : Gender ;
</PRE>
<P></P>
<P>
To abstract over number names, we define the following.
</P>
<PRE>
      Number : Type ; 
    
      singular : Number ;
      plural   : Number ;
</PRE>
<P></P>
<P>
Prepositions used in many-argument functions are either strings
(including the 'accusative' empty string) or strings that
amalgamate with the following word (the 'genitive' <I>di</I> and the
'dative' <I>a</I>).
</P>
<PRE>
      Prep : Type ;
    
      accusative : Prep ;
      genitive   : Prep ;
      dative     : Prep ;
    
      mkPrep : Str -&gt; Prep ;
</PRE>
<P></P>
<A NAME="toc2"></A>
<H2>Nouns</H2>
<P>
Worst case: give both two forms and the gender. 
</P>
<PRE>
      mkN  : (uomo,uomini : Str) -&gt; Gender -&gt; N ;
</PRE>
<P></P>
<P>
The regular function takes the singular form and the gender,
and computes the plural and the gender by a heuristic. 
The heuristic says that the gender is feminine for nouns
ending with <I>a</I>, and masculine for all other words.
</P>
<PRE>
      regN : Str -&gt; N ;
</PRE>
<P></P>
<P>
To force a different gender, use one of the following functions.
</P>
<PRE>
      mascN : N -&gt; N ;
      femN  : N -&gt; N ;
</PRE>
<P></P>
<A NAME="toc3"></A>
<H3>Compound nouns</H3>
<P>
Some nouns are ones where the first part is inflected as a noun but
the second part is not inflected. e.g. <I>numero di telefono</I>. 
They could be formed in syntax, but we give a shortcut here since
they are frequent in lexica.
</P>
<PRE>
      compN : N -&gt; Str -&gt; N ;
</PRE>
<P></P>
<A NAME="toc4"></A>
<H3>Relational nouns</H3>
<P>
Relational nouns (<I>figlio di x</I>) need a case and a preposition. 
</P>
<PRE>
      mkN2 : N -&gt; Prep -&gt; N2 ;
</PRE>
<P></P>
<P>
The most common cases are the genitive <I>di</I> and the dative <I>a</I>, 
with the empty preposition.
</P>
<PRE>
      diN2 : N -&gt; N2 ;
      aN2  : N -&gt; N2 ;
</PRE>
<P></P>
<P>
Three-place relational nouns (<I>la connessione di x a y</I>) need two prepositions.
</P>
<PRE>
      mkN3 : N -&gt; Prep -&gt; Prep -&gt; N3 ;
</PRE>
<P></P>
<A NAME="toc5"></A>
<H3>Relational common noun phrases</H3>
<P>
In some cases, you may want to make a complex <CODE>CN</CODE> into a
relational noun (e.g. <I>la vecchia chiesa di</I>). However, <CODE>N2</CODE> and
<CODE>N3</CODE> are purely lexical categories. But you can use the <CODE>AdvCN</CODE>
and <CODE>PrepNP</CODE> constructions to build phrases like this.
</P>
<A NAME="toc6"></A>
<H3>Proper names and noun phrases</H3>
<P>
Proper names need a string and a gender.
</P>
<PRE>
      mkPN  : Str -&gt; Gender -&gt; PN ;
      regPN : Str -&gt; PN ;           -- feminine if "-a", otherwise masculine
</PRE>
<P></P>
<P>
To form a noun phrase that can also be plural,
you can use the worst-case function.
</P>
<PRE>
      mkNP : Str -&gt; Gender -&gt; Number -&gt; NP ; 
</PRE>
<P></P>
<A NAME="toc7"></A>
<H2>Adjectives</H2>
<P>
Non-comparison one-place adjectives need five forms in the worst
case (masc and fem singular, masc plural, adverbial).
</P>
<PRE>
      mkA : (solo,sola,soli,sole, solamente : Str) -&gt; A ;
</PRE>
<P></P>
<P>
For regular adjectives, all other forms are derived from the
masculine singular. 
</P>
<PRE>
      regA : Str -&gt; A ;
</PRE>
<P></P>
<P>
These functions create postfix adjectives. To switch
them to prefix ones (i.e. ones placed before the noun in
modification, as in <I>vecchia chiesa</I>), the following function is
provided.
</P>
<PRE>
      prefA : A -&gt; A ;
</PRE>
<P></P>
<A NAME="toc8"></A>
<H3>Two-place adjectives</H3>
<P>
Two-place adjectives need a preposition for their second argument.
</P>
<PRE>
      mkA2 : A -&gt; Prep -&gt; A2 ;
</PRE>
<P></P>
<A NAME="toc9"></A>
<H3>Comparison adjectives</H3>
<P>
Comparison adjectives are in the worst case put up from two
adjectives: the positive (<I>buono</I>), and the comparative (<I>migliore</I>). 
</P>
<PRE>
      mkADeg : A -&gt; A -&gt; A ;
</PRE>
<P></P>
<P>
If comparison is formed by <I>più</I>, as usual in Italian,
the following pattern is used:
</P>
<PRE>
      compADeg : A -&gt; A ;
</PRE>
<P></P>
<P>
The regular pattern is the same as <CODE>regA</CODE> for plain adjectives, 
with comparison by <I>più</I>.
</P>
<PRE>
      regADeg : Str -&gt; A ;
</PRE>
<P></P>
<A NAME="toc10"></A>
<H2>Adverbs</H2>
<P>
Adverbs are not inflected. Most lexical ones have position
after the verb. 
</P>
<PRE>
      mkAdv : Str -&gt; Adv ;
</PRE>
<P></P>
<P>
Some appear next to the verb (e.g. <I>sempre</I>).
</P>
<PRE>
      mkAdV : Str -&gt; AdV ;
</PRE>
<P></P>
<P>
Adverbs modifying adjectives and sentences can also be formed.
</P>
<PRE>
      mkAdA : Str -&gt; AdA ;
</PRE>
<P></P>
<A NAME="toc11"></A>
<H2>Verbs</H2>
<P>
Regular verbs are ones with the infinitive <I>are</I> or <I>ire</I>, the
latter with singular present indicative forms as <I>finisco</I>.
The regular verb function is the first conjugation recognizes
these endings, as well as the variations among
<I>amare, cominciare, mangiare, legare, cercare</I>.
</P>
<PRE>
      regV : Str -&gt; V ;
</PRE>
<P></P>
<P>
The module <CODE>BeschIta</CODE> gives (almost) all the patterns of the <I>Bescherelle</I>
book. To use them in the category <CODE>V</CODE>, wrap them with the function
</P>
<PRE>
      verboV : Verbo -&gt; V ;
</PRE>
<P></P>
<P>
The function <CODE>regV</CODE> gives all verbs the compound auxiliary <I>avere</I>.
To change it to <I>essere</I>, use the following function.
Reflexive implies <I>essere</I>.
</P>
<PRE>
      essereV : V -&gt; V ;
      reflV : V -&gt; V ;
</PRE>
<P></P>
<P>
If <CODE>BeschIta</CODE> does not give the desired result or feels difficult
to consult, here is a worst-case function for <I>-ire</I> and <I>-ere</I> verbs,
taking 11 arguments.
</P>
<PRE>
      mkV : 
        (udire,odo,ode,udiamo,udiro,udii,udisti,udi,udirono,odi,udito : Str) -&gt; V ; 
</PRE>
<P></P>
<A NAME="toc12"></A>
<H3>Two-place verbs</H3>
<P>
Two-place verbs need a preposition, except the special case with direct object.
(transitive verbs). Notice that a particle comes from the <CODE>V</CODE>.
</P>
<PRE>
      mkV2  : V -&gt; Prep -&gt; V2 ;
    
      dirV2 : V -&gt; V2 ;
</PRE>
<P></P>
<P>
You can reuse a <CODE>V2</CODE> verb in <CODE>V</CODE>.
</P>
<PRE>
      v2V : V2 -&gt; V ;
</PRE>
<P></P>
<A NAME="toc13"></A>
<H3>Three-place verbs</H3>
<P>
Three-place (ditransitive) verbs need two prepositions, of which
the first one or both can be absent.
</P>
<PRE>
      mkV3     : V -&gt; Prep -&gt; Prep -&gt; V3 ; -- parlare, a, di
      dirV3    : V -&gt; Prep -&gt; V3 ;         -- dare,_,a
      dirdirV3 : V -&gt; V3 ;                 -- dare,_,_
</PRE>
<P></P>
<A NAME="toc14"></A>
<H3>Other complement patterns</H3>
<P>
Verbs and adjectives can take complements such as sentences,
questions, verb phrases, and adjectives.
</P>
<PRE>
      mkV0  : V -&gt; V0 ;
      mkVS  : V -&gt; VS ;
      mkV2S : V -&gt; Prep -&gt; V2S ;
      mkVV  : V -&gt; VV ;  -- plain infinitive: "voglio parlare"
      deVV  : V -&gt; VV ;  -- "cerco di parlare"
      aVV   : V -&gt; VV ;  -- "arrivo a parlare"
      mkV2V : V -&gt; Prep -&gt; Prep -&gt; V2V ;
      mkVA  : V -&gt; VA ;
      mkV2A : V -&gt; Prep -&gt; Prep -&gt; V2A ;
      mkVQ  : V -&gt; VQ ;
      mkV2Q : V -&gt; Prep -&gt; V2Q ;
    
      mkAS  : A -&gt; AS ;
      mkA2S : A -&gt; Prep -&gt; A2S ;
      mkAV  : A -&gt; Prep -&gt; AV ;
      mkA2V : A -&gt; Prep -&gt; Prep -&gt; A2V ;
</PRE>
<P></P>
<P>
Notice: categories <CODE>V2S, V2V, V2Q</CODE> are in v 1.0 treated
just as synonyms of <CODE>V2</CODE>, and the second argument is given
as an adverb. Likewise <CODE>AS, A2S, AV, A2V</CODE> are just <CODE>A</CODE>.
<CODE>V0</CODE> is just <CODE>V</CODE>.
</P>
<PRE>
      V0, V2S, V2V, V2Q : Type ;
      AS, A2S, AV, A2V : Type ;
</PRE>
<P></P>

<!-- html code generated by txt2tags 2.3 (http://txt2tags.sf.net) -->
<!-- cmdline: txt2tags -thtml -\-toc italian/ParadigmsIta.txt -->
</BODY></HTML>
