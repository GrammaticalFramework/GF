----------------------------------------------------------------------
-- |
-- Module      : PGFtoProlog
-- Maintainer  : Peter LjunglÃ¶f
--
-- exports a GF grammar into a Prolog module
-----------------------------------------------------------------------------

module GF.Compile.PGFtoProlog (grammar2prolog) where

import PGF
import PGF.Internal

import GF.Data.Operations

import qualified Data.Array.IArray as Array
import qualified Data.Set as Set
import qualified Data.Map as Map
import qualified Data.IntMap as IntMap
import Data.Char (isAlphaNum, isAscii, isAsciiLower, isAsciiUpper, ord)
import Data.List (isPrefixOf, mapAccumL)

grammar2prolog :: PGF -> String
grammar2prolog pgf
    = ("%% This file was automatically generated by GF" +++++
       ":- style_check(-singleton)." +++++
       plFacts wildCId "abstract" 1 "(?AbstractName)"
                   [[plp name]] ++++
       plFacts wildCId "concrete" 2 "(?AbstractName, ?ConcreteName)" 
                   [[plp name, plp cncname] | 
                    cncname <- languages pgf] ++++
       plAbstract name pgf ++++
       unlines [plConcrete name (lookConcr pgf name) | name <- languages pgf]
      )
    where name = abstractName pgf

----------------------------------------------------------------------
-- abstract syntax

plAbstract :: CId -> PGF -> String
plAbstract name pgf
    = (plHeader "Abstract syntax" ++++
       plFacts name "cat" 2 "(?Type, ?[X:Type,...])"
                   [[plType cat, []] | cat <- categories pgf] ++++
       plFacts name "fun" 3 "(?Fun, ?Type, ?[X:Type,...])"
                   [[plp fun, plType cat, plHypos hypos] |
                    fun <- functions pgf, Just typ <- [functionType pgf fun],
                    let (hypos,cat,_) = unType typ]
      )
    where plType cat = plTerm (plp cat) []
          plHypos hypos = plList [plOper ":" (plp x) (plp ty) | (_, x, ty) <- hypos]

----------------------------------------------------------------------
-- concrete syntax

plConcrete :: CId -> Concr -> String
plConcrete name cnc
    = (plHeader ("Concrete syntax: " ++ plp name) ++++
       plFacts name "prod" 3 "(?CncCat, ?CncFun, ?[CncCat])"
                   [[plCat cat, fun, plTerm "c" (map plCat args)] |
                    cat <- [0..concrTotalCats cnc-1],
                    (fun, args) <- map plProduction (concrProductions cnc cat)] ++++
       plFacts name "cncfun" 3 "(?CncFun, ?[Seq,...], ?AbsFun)"
                   [[plFun funid, plTerm "s" (map plSeq lins), plp absfun] |
                    funid <- [0..concrTotalFuns cnc-1], let (absfun,lins) = concrFunction cnc funid] ++++
       plFacts name "seq" 2 "(?Seq, ?[Term])"
                   [[plSeq seqid, plp (concrSequence cnc seqid)] |
                    seqid <- [0..concrTotalSeqs cnc-1]] ++++
       plFacts name "cnccat" 2 "(?AbsCat, ?[CnCCat])" 
                   [[plp cat, plList (map plCat [start..end])] |
                    (cat,start,end,_) <- concrCategories cnc]
      )
    where plProduction (PCoerce arg)       = ("-", [arg])
          plProduction (PApply funid args) = (plFun funid, [fid | PArg hypos fid <- args])

----------------------------------------------------------------------
-- prolog-printing pgf datatypes

instance PLPrint Type where
    plp ty
      | null hypos = result
      | otherwise  = plOper " -> " plHypos result
      where (hypos,cat,_) = unType ty
            result = plTerm (plp cat) []
            plHypos = plList [plOper ":" (plp x) (plp ty) | (_,x,ty) <- hypos]

instance PLPrint CId where
    plp cid | isLogicalVariable str || cid == wildCId = plVar str
            | otherwise = plAtom str
        where str = showCId cid

instance PLPrint Symbol where
    plp (SymCat n l)    = plOper ":" (show n) (show l)
    plp (SymLit n l)    = plTerm "lit" [show n, show l]
    plp (SymVar n l)    = plTerm "var" [show n, show l]
    plp (SymKS t)       = plAtom t
    plp (SymKP ts alts) = plTerm "pre" [plList (map plp ts), plList (map plAlt alts)]
        where plAlt (ps,ts) = plOper "/" (plList (map plp ps)) (plList (map plAtom ts))

class PLPrint a where
    plp :: a -> String
    plps :: [a] -> String
    plps = plList . map plp

instance PLPrint Char where
    plp  c = plAtom [c]
    plps s = plAtom s

instance PLPrint a => PLPrint [a] where
    plp = plps

----------------------------------------------------------------------
-- other prolog-printing functions

plCat :: Int -> String
plCat n = plAtom ('c' : show n)

plFun :: Int -> String
plFun n = plAtom ('f' : show n)

plSeq :: Int -> String
plSeq n = plAtom ('s' : show n)

plHeader :: String -> String
plHeader hdr = "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% " ++ hdr ++ "\n"

plFacts :: CId -> String -> Int -> String -> [[String]] -> String
plFacts mod pred arity comment facts = "%% " ++ pred ++ comment ++++ clauses
    where clauses = (if facts == [] then ":- dynamic " ++ pred ++ "/" ++ show arity ++ ".\n"
                     else unlines [mod' ++ plTerm pred args ++ "." | args <- facts])
          mod' = if mod == wildCId then "" else plp mod ++ ": "

plTerm :: String -> [String] -> String
plTerm fun args = plAtom fun ++ prParenth (prTList ", " args)

plList :: [String] -> String
plList xs = prBracket (prTList "," xs)

plOper :: String -> String -> String -> String
plOper op a b = prParenth (a ++ op ++ b)

plVar :: String -> String
plVar = varPrefix  . concatMap changeNonAlphaNum 
    where varPrefix var@(c:_) | isAsciiUpper c || c=='_' = var
                              | otherwise = "_" ++ var
          changeNonAlphaNum c | isAlphaNumUnderscore c = [c]
                              | otherwise = "_" ++ show (ord c) ++ "_"

plAtom :: String -> String
plAtom "" = "''"
plAtom atom@(c:cs) | isAsciiLower c && all isAlphaNumUnderscore cs 
                     || c == '\'' && cs /= "" && last cs == '\''   = atom
                   | otherwise = "'" ++ changeQuote atom ++ "'"
    where changeQuote ('\'':cs) = '\\' : '\'' : changeQuote cs
          changeQuote ('\\':cs) = '\\' : '\\' : changeQuote cs
          changeQuote (c:cs) = c : changeQuote cs
          changeQuote "" = ""

isAlphaNumUnderscore :: Char -> Bool
isAlphaNumUnderscore c = (isAscii c && isAlphaNum c) || c == '_'

----------------------------------------------------------------------
-- prolog variables 

createLogicalVariable :: Int -> CId
createLogicalVariable n = mkCId (logicalVariablePrefix ++ show n)

isLogicalVariable :: String -> Bool
isLogicalVariable = isPrefixOf logicalVariablePrefix 

logicalVariablePrefix :: String 
logicalVariablePrefix = "X"
