-- This Happy file was machine-generated by the BNF converter
{
module ParCFG where
import AbsCFG
import LexCFG
import ErrM
}

%name pGrammars Grammars

%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token 
 ';' { PT _ (TS ";") }
 ':' { PT _ (TS ":") }
 '.' { PT _ (TS ".") }
 '->' { PT _ (TS "->") }
 '_' { PT _ (TS "_") }
 '[' { PT _ (TS "[") }
 ']' { PT _ (TS "]") }
 ',' { PT _ (TS ",") }
 'end' { PT _ (TS "end") }
 'grammar' { PT _ (TS "grammar") }
 'startcat' { PT _ (TS "startcat") }

L_ident  { PT _ (TV $$) }
L_integ  { PT _ (TI $$) }
L_quoted { PT _ (TL $$) }
L_SingleQuoteString { PT _ (T_SingleQuoteString $$) }
L_err    { _ }


%%

Ident   : L_ident  { Ident $1 }
Integer : L_integ  { (read $1) :: Integer }
String  : L_quoted { $1 }
SingleQuoteString    : L_SingleQuoteString { SingleQuoteString ($1)}

Grammars :: { Grammars }
Grammars : ListGrammar { Grammars (reverse $1) } 


Grammar :: { Grammar }
Grammar : 'grammar' Ident ListFlag ListRule 'end' 'grammar' { Grammar $2 (reverse $3) (reverse $4) } 


ListGrammar :: { [Grammar] }
ListGrammar : {- empty -} { [] } 
  | ListGrammar Grammar { flip (:) $1 $2 }


Flag :: { Flag }
Flag : 'startcat' Category { StartCat $2 } 


ListFlag :: { [Flag] }
ListFlag : {- empty -} { [] } 
  | ListFlag Flag ';' { flip (:) $1 $2 }


Rule :: { Rule }
Rule : Fun ':' Profile '.' Category '->' ListSymbol { Rule $1 $3 $5 $7 } 


ListRule :: { [Rule] }
ListRule : {- empty -} { [] } 
  | ListRule Rule ';' { flip (:) $1 $2 }


Fun :: { Fun }
Fun : Ident { Cons $1 } 
  | '_' { Coerce }


Profile :: { Profile }
Profile : '[' ListInts ']' { Profile $2 } 


Ints :: { Ints }
Ints : '[' ListInteger ']' { Ints $2 } 


ListInts :: { [Ints] }
ListInts : {- empty -} { [] } 
  | Ints { (:[]) $1 }
  | Ints ',' ListInts { (:) $1 $3 }


ListInteger :: { [Integer] }
ListInteger : {- empty -} { [] } 
  | Integer { (:[]) $1 }
  | Integer ',' ListInteger { (:) $1 $3 }


Symbol :: { Symbol }
Symbol : Category { CatS $1 } 
  | String { TermS $1 }


ListSymbol :: { [Symbol] }
ListSymbol : '.' { [] } 
  | Symbol { (:[]) $1 }
  | Symbol ListSymbol { (:) $1 $2 }


Category :: { Category }
Category : SingleQuoteString { Category $1 } 



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ if null ts then [] else (" before " ++ unwords (map prToken (take 4 ts)))

myLexer = tokens
}

